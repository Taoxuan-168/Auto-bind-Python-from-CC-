'''
    @brief Generate C++ code for Python API bindings
'''

import os
import argparse
import time
import sys
import json

def generate_api_cpp(api_tree, header_path, module_name, out_path=None):
    """
    Generate pybind11 binding code for a single header file.
    
    Args:
        api_tree: The parsed API tree
        header_path: Path to the header file
        module_name: The root module name (derived from header filename)
        out_path: Output file path
    
    Returns:
        Generated C++ code string
    """
    content = '''
// This file is generated by gen_api.py,
// !! DO NOT edit this file manually

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>
#include <pybind11/functional.h>
#include <pybind11/chrono.h>

#include "{header_name}"


namespace py = pybind11;


PYBIND11_MODULE({module_name}, m) {{
    {code}
}}
'''
    code = []
    
    if module_name not in api_tree.get("members", {}):
        # No API found for this module
        return None
    
    root_module = api_tree["members"][module_name]
    code.append('m.doc() = "{}";'.format(_get_doc_string(root_module)))
    
    def gen_members(members, _code, parent_var, parent_name, parent_type, parent_names, cpp_namespace):
        """
        Generate binding code for members.
        
        Args:
            members: Dict of members to process
            _code: List to append generated code to
            parent_var: Variable name of parent in pybind11 (e.g., "m", "m_test")
            parent_name: Name of the parent
            parent_type: Type of parent ("module", "class", etc.)
            parent_names: List of Python module/class names (for pybind11 structure)
            cpp_namespace: List of C++ namespace parts (for actual C++ symbols)
        """
        for k, v in members.items():
            doc = _get_doc_string(v)
            doc = doc.replace("\n", "\\n").replace('"', '\\"')
            
            if v["type"] == "module":
                sub_m_name = "m_{}".format(k)
                _code.append('auto {} = {}.def_submodule("{}", "{}");'.format(sub_m_name, parent_var, k, doc))
                # 模块名同时也是 C++ 命名空间的一部分
                gen_members(v["members"], _code, sub_m_name, k, v["type"], parent_names + [k], cpp_namespace + [k])
            
            elif v["type"] == "class":
                sub_obj_name = "class_{}_{}".format("_".join(parent_names) if parent_names else "root", k)
                cpp_class_name = "::".join(cpp_namespace + [k])
                _code.append('auto {} = py::class_<{}>({}, "{}");'.format(sub_obj_name, cpp_class_name, parent_var, k))
                gen_members(v["members"], _code, sub_obj_name, k, v["type"], parent_names + [k], cpp_namespace + [k])
            
            elif v["type"] == "func":
                kwargs_str = ", ".join(['py::arg("{}") {}'.format(x[1], '= {}'.format(x[2]) if x[2] is not None else "") for x in v["args"]])
                if kwargs_str:
                    kwargs_str = ", " + kwargs_str
                
                if k == "__init__":
                    _code.append('{}.def(py::init<{}>(){});'.format(parent_var, ", ".join([x[0] for x in v["args"]]), kwargs_str))
                elif k == "__iter__":
                    cpp_class_name = "::".join(cpp_namespace)
                    _code.append('{}.def("__iter__", []({} &c){{return py::make_iterator(c.begin(), c.end());}}, py::keep_alive<0, 1>());'.format(parent_var, cpp_class_name))
                elif k == "__del__":
                    raise Exception("not support __del__ yet")
                else:
                    func_name = v["name"]
                    ret_policy = "reference" if v["ret_type"].endswith("&") else "take_ownership"
                    
                    # 构建完整的 C++ 函数引用
                    if parent_type == "class" and not v["static"]:
                        # 类成员函数
                        cpp_func_ref = "&{}::{}".format("::".join(cpp_namespace), func_name)
                        cast_class = "::".join(cpp_namespace) + "::*"
                    else:
                        # 普通函数或静态函数
                        if len(cpp_namespace) > 0:
                            cpp_func_ref = "&{}::{}".format("::".join(cpp_namespace), func_name)
                        else:
                            cpp_func_ref = "&{}".format(func_name)
                        cast_class = "*"
                    
                    _code.append('{}.def{}("{}", static_cast<{} ({})({})>({}), py::return_value_policy::{}, "{}"{});'.format(
                        parent_var, 
                        "_static" if v["static"] else "", 
                        k,
                        v["ret_type"],
                        cast_class,
                        ", ".join([x[0] for x in v["args"]]),
                        cpp_func_ref,
                        ret_policy,
                        doc, 
                        kwargs_str
                    ))
            
            elif v["type"] == "var":
                if parent_type == "class":
                    cpp_var_name = "::".join(cpp_namespace + [k])
                    if v["readonly"]:
                        _code.append('{}.def_readonly{}("{}", &{});'.format(parent_var, "_static" if v["static"] else "", k, cpp_var_name))
                    else:
                        _code.append('{}.def_readwrite{}("{}", &{});'.format(parent_var, "_static" if v["static"] else "", k, cpp_var_name))
                else:
                    cpp_var_name = "::".join(cpp_namespace + [k])
                    _code.append('{}.attr("{}") = {};'.format(parent_var, k, cpp_var_name))
            
            elif v["type"] == "enum":
                cpp_enum_name = "::".join(cpp_namespace + [k])
                _code.append('py::enum_<{}>({}, "{}")'.format(cpp_enum_name, parent_var, k))
                for enum_k, enum_v, comment in v["values"]:
                    cpp_enum_value = "::".join(cpp_namespace + [k, enum_k])
                    _code.append('    .value("{}", {})'.format(enum_k, cpp_enum_value))
                _code.append(';')

    # 从根模块开始，cpp_namespace 初始为根模块名（即 C++ 命名空间）
    gen_members(root_module["members"], code, parent_var="m", parent_name=module_name, parent_type="module", parent_names=[], cpp_namespace=[module_name])

    code_str = "\n    ".join(code)
    header_name = os.path.basename(header_path)
    content = content.format(header_name=header_name, module_name=module_name, code=code_str)
    
    if out_path:
        if os.path.dirname(out_path):
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(content)
    
    return content


def generate_docs(api_tree, module_name, doc_out_dir, module_to_md=None):
    """
    Generate documentation for a module.
    
    Args:
        api_tree: The parsed API tree
        module_name: The root module name
        doc_out_dir: Output directory for documentation
        module_to_md: Function to convert module to markdown (from gen_markdown)
    """
    import yaml
    
    if module_name not in api_tree.get("members", {}):
        return
    
    os.makedirs(doc_out_dir, exist_ok=True)
    
    # Save API JSON
    api_json_path = os.path.join(doc_out_dir, f"api_{module_name}.json")
    with open(api_json_path, "w", encoding="utf-8") as f:
        json.dump(api_tree, f, indent=4, ensure_ascii=False)
    
    # Generate sidebar
    sidebar = {
        "items": [
            {
                "label": "Brief",
                "file": "README.md"
            }
        ]
    }
    
    doc_module_sidebar = {
        "label": module_name,
        "collapsed": False,
        "items": []
    }
    sidebar["items"].append(doc_module_sidebar)
    
    # Template for module documentation header
    start_comment_template = '''
> This is `{}` module documentation.
> All of these elements are in namespace `{}`.
>
> DO NOT edit this doc file manually, this doc is auto generated!
\n'''
    
    module_members = api_tree["members"][module_name]["members"]
    
    def gen_modules_doc(module_members, parents):
        sidebar_items = []
        for m, v in module_members.items():
            if v["type"] == "module":
                item = {
                    "label": m,
                    "collapsed": False,
                    "file": "{}.md".format("/".join(parents) + "/" + m)
                }
                sidebar_items.append(item)
                api_file = os.path.join(doc_out_dir, item["file"])
                os.makedirs(os.path.dirname(api_file), exist_ok=True)
                module_full_name = ".".join(parents + [m])
                start_comment = start_comment_template.format(module_full_name, module_full_name)
                
                if module_to_md:
                    content = module_to_md(parents, m, v, start_comment, module_join_char=".")
                else:
                    content = generate_simple_md(parents, m, v, start_comment)
                
                with open(api_file, "w", encoding="utf-8") as f:
                    f.write(content)
                
                # Find submodules
                for _k, _v in v["members"].items():
                    if _v["type"] == "module":
                        item["items"] = gen_modules_doc(v["members"], parents + [m])
        return sidebar_items
    
    sidebar_items = gen_modules_doc(module_members, [module_name])
    doc_module_sidebar["items"] += sidebar_items
    
    # Save sidebar
    side_bar_path = os.path.join(doc_out_dir, f"sidebar_{module_name}.yaml")
    with open(side_bar_path, "w", encoding="utf-8") as f:
        yaml.dump(sidebar, f, indent=4, allow_unicode=True)
    
    # Generate README
    readme_path = os.path.join(doc_out_dir, f"README_{module_name}.md")
    readme = f'''
---
title: {module_name} API Documentation
---

> This API documentation is auto-generated from source code.

## Modules

'''
    readme += "| Module | Description |\n"
    readme += "| --- | --- |\n"
    for m, v in module_members.items():
        brief = v.get("doc", {}).get("brief", "") if isinstance(v.get("doc"), dict) else str(v.get("doc", ""))
        readme += f"| [{module_name}.{m}](./{module_name}/{m}.md) | {brief.replace(chr(10), '<br>')} |\n"
    
    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(readme)
    
    print(f"-- Generated docs: {doc_out_dir}")


def generate_simple_md(parents, name, module_data, start_comment):
    """
    Generate simple markdown documentation for a module.
    Used as fallback when module_to_md is not available.
    """
    content = f"# {'.'.join(parents)}.{name}\n\n"
    content += start_comment
    
    doc = module_data.get("doc", {})
    if isinstance(doc, dict):
        brief = doc.get("brief", "")
    else:
        brief = str(doc)
    
    if brief:
        content += f"\n{brief}\n\n"
    
    members = module_data.get("members", {})
    
    # Functions
    funcs = {k: v for k, v in members.items() if v.get("type") == "func"}
    if funcs:
        content += "## Functions\n\n"
        for fname, fdata in funcs.items():
            fdoc = fdata.get("doc", {})
            fbrief = fdoc.get("brief", "") if isinstance(fdoc, dict) else ""
            args = fdata.get("args", [])
            args_str = ", ".join([f"{a[0]} {a[1]}" for a in args])
            ret_type = fdata.get("ret_type", "void")
            content += f"### {fname}\n\n"
            content += f"```cpp\n{ret_type} {fname}({args_str})\n```\n\n"
            if fbrief:
                content += f"{fbrief}\n\n"
            if args:
                content += "**Parameters:**\n\n"
                for arg in args:
                    param_doc = fdoc.get("param", {}).get(arg[1], "") if isinstance(fdoc, dict) else ""
                    content += f"- `{arg[1]}` ({arg[0]}): {param_doc}\n"
                content += "\n"
    
    # Classes
    classes = {k: v for k, v in members.items() if v.get("type") == "class"}
    if classes:
        content += "## Classes\n\n"
        for cname, cdata in classes.items():
            cdoc = cdata.get("doc", {})
            cbrief = cdoc.get("brief", "") if isinstance(cdoc, dict) else ""
            content += f"### {cname}\n\n"
            if cbrief:
                content += f"{cbrief}\n\n"
    
    # Enums
    enums = {k: v for k, v in members.items() if v.get("type") == "enum"}
    if enums:
        content += "## Enums\n\n"
        for ename, edata in enums.items():
            edoc = edata.get("doc", {})
            ebrief = edoc.get("brief", "") if isinstance(edoc, dict) else ""
            content += f"### {ename}\n\n"
            if ebrief:
                content += f"{ebrief}\n\n"
            values = edata.get("values", [])
            if values:
                content += "| Value | Description |\n"
                content += "| --- | --- |\n"
                for val in values:
                    content += f"| `{val[0]}` | {val[2] if len(val) > 2 else ''} |\n"
                content += "\n"
    
    # Variables
    vars_ = {k: v for k, v in members.items() if v.get("type") == "var"}
    if vars_:
        content += "## Variables\n\n"
        for vname, vdata in vars_.items():
            vdoc = vdata.get("doc", {})
            vbrief = vdoc.get("brief", "") if isinstance(vdoc, dict) else ""
            content += f"### {vname}\n\n"
            if vbrief:
                content += f"{vbrief}\n\n"
    
    return content


def _get_doc_string(v):
    """Extract documentation string from an API item."""
    if type(v.get("doc")) == str:
        return v["doc"]
    else:
        doc = v.get("doc", {}).get("py_doc", "")
        if not doc:
            doc = v.get("doc", {}).get("brief", "")
        return doc


def get_module_name_from_header(header_path):
    """
    Get module name from header file path.
    
    Examples:
        add.hpp -> add
        my_utils.h -> my_utils
        /path/to/math.hpp -> math
    """
    basename = os.path.basename(header_path)
    # Remove extension (.h, .hpp, .hxx, etc.)
    name = os.path.splitext(basename)[0]
    return name


def sort_headers(headers, priority_file=None):
    """Sort headers by priority file if exists."""
    if priority_file is None:
        priority_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "headers_priority.txt")
    
    if not os.path.exists(priority_file):
        return headers
    
    headers_priority = []
    with open(priority_file, "r", encoding="utf-8") as f:
        for line in f.readlines():
            line = line.strip()
            if line.startswith("#") or not line:
                continue
            headers_priority.append(line)
    
    headers = sorted(headers, key=lambda x: headers_priority.index(os.path.basename(x)) if os.path.basename(x) in headers_priority else len(headers_priority))
    return headers


if __name__ == "__main__":
    print("-- Generate C/C++ API bindings")
    parser = argparse.ArgumentParser(description='Generate C/C++ API bindings (one module per header file)')
    parser.add_argument('--vars', type=str, default="", help="CMake global variables file")
    parser.add_argument('-i', '--input', type=str, default="./main/include", help="Input directory for header files (default: ./main/include)")
    parser.add_argument('-o', '--output', type=str, default="./main/src", help="Output directory for binding files (default: ./main/src)")
    parser.add_argument('--sdk_path', type=str, default="./", help="SDK path")
    parser.add_argument('--sdk_tag', type=str, default="module", help="SDK tag to search for in comments (default: module)")
    parser.add_argument('--doc', type=str, default="", help="Output directory for documentation (optional, no doc generated if not specified)")
    args = parser.parse_args()

    t = time.time()

    # Setup import path
    sys.path.insert(0, args.sdk_path)
    tools_path = os.path.join(args.sdk_path, "tools")
    if os.path.exists(tools_path):
        sys.path.insert(0, tools_path)
    
    from doc_tool.gen_api import get_headers_recursive, parse_api_from_header
    
    # Try to import module_to_md for better documentation
    module_to_md = None
    try:
        from doc_tool.gen_markdown import module_to_md
    except ImportError:
        pass

    # Get header files
    headers = []
    input_path = args.input
    
    if args.vars:
        with open(args.vars, "r", encoding="utf-8") as f:
            vars_data = json.load(f)
        for include_dir in vars_data["includes"]:
            headers += get_headers_recursive(include_dir)
    elif os.path.exists(input_path):
        for root, dirs, files in os.walk(input_path):
            for name in files:
                path = os.path.join(root, name)
                if path.endswith(".h") or path.endswith(".hpp"):
                    headers.append(path)
    else:
        print(f"Error: Input directory not found: {input_path}")
        sys.exit(1)

    # Sort headers
    headers = sort_headers(headers)

    # Create output directory
    os.makedirs(args.output, exist_ok=True)
    
    # Create doc output directory if specified
    if args.doc:
        os.makedirs(args.doc, exist_ok=True)

    # Process each header file separately
    generated_modules = []
    
    for header in headers:
        # Get module name from header filename
        module_name = get_module_name_from_header(header)
        
        # Parse API from this single header
        api_tree = {}
        try:
            api_tree, updated, keys = parse_api_from_header(
                header, 
                api_tree, 
                sdks=[args.sdk_tag], 
                module_name=module_name
            )
        except Exception as e:
            print(f"-- Warning: Failed to parse {header}: {e}")
            continue
        
        if not updated:
            # No API found in this header
            continue
        
        # Generate binding file
        output_file = os.path.join(args.output, f"bind_{module_name}.cpp")
        content = generate_api_cpp(api_tree, header, module_name, output_file)
        
        if content:
            generated_modules.append({
                "name": module_name,
                "header": header,
                "binding": output_file,
                "api_tree": api_tree
            })
            print(f"-- Generated binding: {output_file} (module: {module_name})")
        
        # Generate documentation if --doc is specified
        if args.doc and content:
            generate_docs(api_tree, module_name, args.doc, module_to_md)

    # Generate summary
    print(f"\n-- Summary: Generated {len(generated_modules)} module(s) in {time.time() - t:.2f}s")
    for mod in generated_modules:
        print(f"   - {mod['name']} from {os.path.basename(mod['header'])}")
    
    if args.doc:
        print(f"\n-- Documentation generated in: {args.doc}")
    
    print(f"\n-- To use in Python:")
    for mod in generated_modules:
        print(f"   import {mod['name']}")